package management

import (
	"database/sql"

	"github.com/ResultadosDigitais/x9/db"
)

// Vulnerability contains the database fields
// of vulnerabilities table
type Vulnerability struct {
	ID            string `json:"id"`
	InternalID    string `json:"-"`
	Name          string `json:"name"`
	Repository    string `json:"repository"`
	FileName      string `json:"filename"`
	Tool          string `json:"tool"`
	Value         string `json:"value"`
	FalsePositive bool   `json:"false_positive"`
	IssueURL      string `json:"issue_url"`
}

// InsertVulnerability inserts a new vulnerability
// if it does not exists
func InsertVulnerability(v Vulnerability) (Vulnerability, error) {
	v.ID = getID(v.Name, v.Repository, v.Tool, v.Value, v.FileName)

	if vuln, err := GetVulnerabilityByID(v.ID); err == nil {
		return vuln, nil
	} else if err != sql.ErrNoRows {
		return Vulnerability{}, err
	}

	sql := `INSERT INTO vulnerabilities VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`

	return v, db.Exec(sql, v.ID, v.Name, v.Repository, v.FileName, v.Tool, v.Value, v.FalsePositive, v.IssueURL)

}

// GetVulnerabilityByID search for a single vulnerability
// that maches with the id
func GetVulnerabilityByID(id string) (Vulnerability, error) {
	sql := `SELECT * FROM vulnerabilities
			  WHERE id = $1`

	row, err := db.QueryRow(sql, id)
	if err != nil {
		return Vulnerability{}, err
	}
	return processRow(row)

}

// GetVulnerabilitiesByRepo gets all vulnerabilities
// related to a repository
func GetVulnerabilitiesByRepo(repo string) ([]Vulnerability, error) {
	sql := `SELECT * FROM vulnerabilities
			WHERE repository LIKE %$1%`

	rows, err := db.Query(sql, repo)
	if err != nil {
		return nil, err
	}
	return processRows(rows)
}

// GetVulnerabilitiesByName gets all vulnerabilities
// related to a vulnerability name
func GetVulnerabilitiesByName(name string) ([]Vulnerability, error) {
	sql := `SELECT * FROM vulnerabilities
			WHERE name = $1`

	rows, err := db.Query(sql, name)
	if err != nil {
		return nil, err
	}
	return processRows(rows)
}

// SetAsFalsePositive sets the Vulnerability as a
// false positive
func SetAsFalsePositive(id string) error {
	sql := `UPDATE vulnerabilities
			SET false_positive = TRUE
			WHERE id = $1`
	return db.Exec(sql, id)
}

func SetIssueURL(id, url string) error {
	sql := `UPDATE vulnerabilities
			SET issue_url = $1
			WHERE id = $2`
	return db.Exec(sql, url, id)
}

func processRow(row *sql.Row) (Vulnerability, error) {
	v := Vulnerability{}

	err := row.Scan(
		&v.ID,
		&v.Name,
		&v.Repository,
		&v.FileName,
		&v.Tool,
		&v.Value,
		&v.FalsePositive,
		&v.IssueURL,
	)

	return v, err
}

func processRows(rows *sql.Rows) ([]Vulnerability, error) {
	vs := []Vulnerability{}

	for rows.Next() {
		var v Vulnerability
		err := rows.Scan(
			&v.ID,
			&v.Name,
			&v.Repository,
			&v.FileName,
			&v.Tool,
			&v.Value,
			&v.FalsePositive,
			&v.IssueURL,
		)
		if err != nil {
			return nil, err
		}
		vs = append(vs, v)
	}
	return vs, nil
}
