package management

import (
	"database/sql"

	"github.com/ResultadosDigitais/x9/db"
)

// Vulnerability contains the database fields
// of vulnerabilities table
type Vulnerability struct {
	ID            string `json:"id"`
	InternalID    string `json:"-"`
	Name          string `json:"name"`
	Repository    string `json:"repository"`
	FileName      string `json:"filename"`
	Tool          string `json:"tool"`
	Value         string `json:"value"`
	FalsePositive bool   `json:"false_positive"`
	IssueURL      string `json:"issue_url"`
}

// InsertVulnerability inserts a new vulnerability
// if it does not exists
func InsertVulnerability(v Vulnerability) (string, error) {
	var err error

	v.ID, err = generateID()
	if err != nil {
		return "", err
	}
	v.InternalID = getInternalID(v.Name, v.Repository, v.Tool, v.Value, v.FileName)
	if err != nil {
		return "", err
	}
	sql := `INSERT INTO vulnerabilities VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`

	return v.ID, db.Exec(sql, v.ID, v.InternalID, v.Name, v.Repository, v.FileName, v.Tool, v.Value, v.FalsePositive, v.IssueURL)

}

// GetVulnerabilityByID search for a single vulnerability
// that maches with the id
func GetVulnerabilityByID(id string) (Vulnerability, error) {
	var v Vulnerability
	sql := `SELECT * FROM vulnerabilities
			  WHERE id = $1`

	row, err := db.Query(sql, id)
	if err != nil {
		return v, err
	}
	vs, err := processRows(row)
	if err == nil && len(vs) > 0 {
		v = vs[0]
	}
	return v, err
}

// GetVulnerabilitiesByRepo gets all vulnerabilities
// related to a repository
func GetVulnerabilitiesByRepo(repo string) ([]Vulnerability, error) {
	sql := `SELECT * FROM vulnerabilities
			WHERE repository LIKE %$1%`

	rows, err := db.Query(sql, repo)
	if err != nil {
		return nil, err
	}
	return processRows(rows)
}

// GetVulnerabilitiesByName gets all vulnerabilities
// related to a vulnerability name
func GetVulnerabilitiesByName(name string) ([]Vulnerability, error) {
	sql := `SELECT * FROM vulnerabilities
			WHERE name = $1`

	rows, err := db.Query(sql, name)
	if err != nil {
		return nil, err
	}
	return processRows(rows)
}

// SetAsFalsePositive sets the Vulnerability as a
// false positive
func SetAsFalsePositive(id string) error {
	sql := `UPDATE TABLE vulnerability
			SET false_positive = true
			WHERE id = $1`
	return db.Exec(sql, id)
}

func SetIssueURL(id, url string) error {
	sql := `UPDATE TABLE vulnerability
			SET issue_url = $1
			WHERE id = $2 AND issue_url IS NULL`
	return db.Exec(sql, url, id)
}

func processRows(rows *sql.Rows) ([]Vulnerability, error) {
	vs := []Vulnerability{}

	for rows.Next() {
		var v Vulnerability
		err := rows.Scan(
			&v.ID,
			&v.InternalID,
			&v.Name,
			&v.Repository,
			&v.FileName,
			&v.Tool,
			&v.Value,
			&v.FalsePositive,
			&v.IssueURL,
		)
		if err != nil {
			return nil, err
		}
		vs = append(vs, v)
	}
	return vs, nil
}
